// closures_complete.jb - Gu√≠a Completa de Closures en Jabline
// ===========================================================

echo("üîí CLOSURES EN JABLINE - GU√çA COMPLETA")
echo("======================================")
echo("")

// =============================================================================
// 1. CLOSURES B√ÅSICOS - Fundamentos
// =============================================================================

echo("1. CLOSURES B√ÅSICOS:")
echo("-------------------")

fn createCounter(start) {
    let count = start

    return fn() {
        count = count + 1
        return count
    }
}

let counter1 = createCounter(0)
let counter2 = createCounter(100)

echo("counter1(): " + counter1())  // 1
echo("counter1(): " + counter1())  // 2
echo("counter2(): " + counter2())  // 101 (independiente)
echo("")

// =============================================================================
// 2. ARROW FUNCTION CLOSURES
// =============================================================================

echo("2. ARROW FUNCTION CLOSURES:")
echo("---------------------------")

let createMultiplier = factor => x => x * factor

let double = createMultiplier(2)
let triple = createMultiplier(3)

echo("double(5): " + double(5))      // 10
echo("triple(5): " + triple(5))      // 15
echo("")

// =============================================================================
// 3. FACTORY PATTERN - Creaci√≥n de Objetos con Estado
// =============================================================================

echo("3. FACTORY PATTERN:")
echo("-------------------")

fn createBankAccount(initialBalance, accountName) {
    let balance = initialBalance
    let name = accountName
    let transactionCount = 0

    return {
        "deposit": fn(amount) {
            balance = balance + amount
            transactionCount = transactionCount + 1
            return "Depositado $" + amount + ". Balance: $" + balance
        },

        "withdraw": fn(amount) {
            if (balance >= amount) {
                balance = balance - amount
                transactionCount = transactionCount + 1
                return "Retirado $" + amount + ". Balance: $" + balance
            } else {
                return "Fondos insuficientes. Balance: $" + balance
            }
        },

        "getInfo": fn() {
            return name + " - Balance: $" + balance + " - Transacciones: " + transactionCount
        }
    }
}

let account = createBankAccount(1000, "Juan P√©rez")
echo(account["deposit"](250))
echo(account["withdraw"](100))
echo(account["getInfo"]())
echo("")

// =============================================================================
// 4. MODULE PATTERN - Encapsulaci√≥n Completa
// =============================================================================

echo("4. MODULE PATTERN:")
echo("------------------")

let UserModule = fn() {
    // Variables privadas
    let users = []
    let currentId = 1

    // Funci√≥n privada
    let generateId = fn() {
        let id = currentId
        currentId = currentId + 1
        return id
    }

    // API p√∫blica
    return {
        "create": fn(name, email) {
            let user = {
                "id": generateId(),
                "name": name,
                "email": email,
                "active": true
            }
            users = push(users, user)
            return user
        },

        "getById": fn(id) {
            for (user in users) {
                if (user["id"] == id) {
                    return user
                }
            }
            return null
        },

        "count": fn() {
            return len(users)
        }
    }
}()  // IIFE - Immediately Invoked Function Expression

let user1 = UserModule["create"]("Ana Garc√≠a", "ana@example.com")
let user2 = UserModule["create"]("Carlos L√≥pez", "carlos@example.com")

echo("Usuario creado: " + user1["name"] + " (ID: " + user1["id"] + ")")
echo("Total usuarios: " + UserModule["count"]())
echo("")

// =============================================================================
// 5. CLOSURES ANIDADOS - M√∫ltiples Niveles
// =============================================================================

echo("5. CLOSURES ANIDADOS:")
echo("---------------------")

fn createCalculatorFactory(baseNumber) {
    return fn(operation) {
        return fn(number) {
            if (operation == "add") {
                return baseNumber + number
            } else {
                if (operation == "multiply") {
                    return baseNumber * number
                } else {
                    if (operation == "power") {
                        let result = 1
                        for (let i = 0; i < number; i = i + 1) {
                            result = result * baseNumber
                        }
                        return result
                    } else {
                        return 0
                    }
                }
            }
        }
    }
}

let calc10 = createCalculatorFactory(10)
let adder = calc10("add")
let multiplier = calc10("multiply")
let power = calc10("power")

echo("10 + 5 = " + adder(5))
echo("10 * 3 = " + multiplier(3))
echo("10^2 = " + power(2))
echo("")

// =============================================================================
// 6. EVENT EMITTER CON CLOSURES
// =============================================================================

echo("6. EVENT EMITTER:")
echo("-----------------")

fn createEventEmitter() {
    let listeners = {}

    return {
        "on": fn(event, callback) {
            if (listeners[event] == null) {
                listeners[event] = []
            }
            listeners[event] = push(listeners[event], callback)
        },

        "emit": fn(event, data) {
            if (listeners[event] != null) {
                let eventListeners = listeners[event]
                for (callback in eventListeners) {
                    callback(data)
                }
                return len(eventListeners)
            }
            return 0
        }
    }
}

let emitter = createEventEmitter()

// Registrar listeners que capturan variables del entorno externo
let appName = "MiApp"
emitter["on"]("userLogin", fn(user) {
    echo("  " + appName + ": Usuario " + user + " se conect√≥")
})

emitter["on"]("userLogin", fn(user) {
    echo("  Sistema: Actualizando estad√≠sticas para " + user)
})

// Emitir eventos
let notifiedCount = emitter["emit"]("userLogin", "juan123")
echo("Listeners notificados: " + notifiedCount)
echo("")

// =============================================================================
// 7. MEMOIZATION - Optimizaci√≥n con Closures
// =============================================================================

echo("7. MEMOIZATION:")
echo("---------------")

fn memoize(fn) {
    let cache = {}
    let hits = 0
    let misses = 0

    return {
        "call": fn(arg) {
            let key = str(arg)

            if (cache[key] != null) {
                hits = hits + 1
                echo("  Cache HIT para " + arg + " (total hits: " + hits + ")")
                return cache[key]
            } else {
                misses = misses + 1
                echo("  Cache MISS para " + arg + " (total misses: " + misses + ")")
                let result = fn(arg)
                cache[key] = result
                return result
            }
        },

        "getStats": fn() {
            return "Hits: " + hits + ", Misses: " + misses
        }
    }
}

// Funci√≥n costosa para memoizar
fn fibonacci(n) {
    if (n <= 1) {
        return n
    }
    return n * (n - 1)  // Simplificado para el ejemplo
}

let memoizedFib = memoize(fibonacci)

echo("Calculando fibonacci(10):")
let result1 = memoizedFib["call"](10)
echo("Resultado: " + result1)

echo("Calculando fibonacci(10) nuevamente:")
let result2 = memoizedFib["call"](10)
echo("Resultado: " + result2)

echo("Estad√≠sticas: " + memoizedFib["getStats"]())
echo("")

// =============================================================================
// 8. PARTIAL APPLICATION Y CURRYING
// =============================================================================

echo("8. CURRYING Y PARTIAL APPLICATION:")
echo("----------------------------------")

// Funci√≥n que suma 3 n√∫meros con currying
let add = a => b => c => a + b + c

// Aplicaci√≥n parcial
let add5 = add(5)          // Fija el primer par√°metro
let add5And10 = add5(10)   // Fija el segundo par√°metro

echo("add(1)(2)(3): " + add(1)(2)(3))       // 6
echo("add5(2)(3): " + add5(2)(3))           // 10
echo("add5And10(7): " + add5And10(7))       // 22

// Aplicaci√≥n pr√°ctica: validadores
let createValidator = property => expectedValue => fn(obj) {
    return obj[property] == expectedValue
}

let isAdmin = createValidator("role")("admin")
let isActive = createValidator("status")("active")

let user = {"name": "Juan", "role": "admin", "status": "active"}
echo("Es admin: " + isAdmin(user))
echo("Est√° activo: " + isActive(user))
echo("")

// =============================================================================
// 9. STATE MACHINE CON CLOSURES
// =============================================================================

echo("9. STATE MACHINE:")
echo("-----------------")

fn createStateMachine() {
    let state = "idle"
    let history = ["idle"]

    return {
        "getState": fn() {
            return state
        },

        "start": fn() {
            if (state == "idle") {
                state = "running"
                history = push(history, "running")
                return "Iniciado correctamente"
            } else {
                return "No se puede iniciar desde estado: " + state
            }
        },

        "pause": fn() {
            if (state == "running") {
                state = "paused"
                history = push(history, "paused")
                return "Pausado"
            } else {
                return "No se puede pausar desde estado: " + state
            }
        },

        "stop": fn() {
            if (state == "running" || state == "paused") {
                state = "stopped"
                history = push(history, "stopped")
                return "Detenido"
            } else {
                return "No se puede detener desde estado: " + state
            }
        },

        "getHistory": fn() {
            return history
        }
    }
}

let machine = createStateMachine()
echo("Estado inicial: " + machine["getState"]())
echo(machine["start"]())
echo("Estado: " + machine["getState"]())
echo(machine["pause"]())
echo(machine["stop"]())
echo("Historia: " + machine["getHistory"]()[0] + " -> " + machine["getHistory"]()[1] + " -> " + machine["getHistory"]()[2] + " -> " + machine["getHistory"]()[3])
echo("")

// =============================================================================
// 10. PIPELINE DE TRANSFORMACIONES
// =============================================================================

echo("10. PIPELINE DE TRANSFORMACIONES:")
echo("---------------------------------")

fn createPipeline() {
    let transformations = []

    return {
        "add": fn(transform) {
            transformations = push(transformations, transform)
            return this  // Para encadenamiento fluido
        },

        "execute": fn(input) {
            let result = input
            echo("  Entrada: " + result)

            for (let i = 0; i < len(transformations); i = i + 1) {
                let oldResult = result
                result = transformations[i](result)
                echo("  Paso " + (i + 1) + ": " + oldResult + " ‚Üí " + result)
            }

            return result
        }
    }
}

let pipeline = createPipeline()
pipeline["add"](fn(x) { return x * 2 })      // Doblar
pipeline["add"](fn(x) { return x + 10 })     // Sumar 10
pipeline["add"](fn(x) { return x / 3 })      // Dividir por 3

let finalResult = pipeline["execute"](5)
echo("Resultado final: " + finalResult)
echo("")

// =============================================================================
// RESUMEN Y MEJORES PR√ÅCTICAS
// =============================================================================

echo("‚ú® CARACTER√çSTICAS DE CLOSURES EN JABLINE:")
echo("==========================================")
echo("‚Ä¢ ‚úÖ Captura autom√°tica de variables del entorno externo")
echo("‚Ä¢ ‚úÖ Preservaci√≥n del estado entre llamadas")
echo("‚Ä¢ ‚úÖ Soporte para funciones anidadas m√∫ltiples niveles")
echo("‚Ä¢ ‚úÖ Compatibilidad total con arrow functions")
echo("‚Ä¢ ‚úÖ Variables compartidas entre m√∫ltiples closures")
echo("‚Ä¢ ‚úÖ Estado persistente y encapsulaci√≥n de datos")
echo("‚Ä¢ ‚úÖ Programaci√≥n funcional avanzada")
echo("")

echo("üí° CASOS DE USO PRINCIPALES:")
echo("=============================")
echo("‚Ä¢ Factory Pattern - Creaci√≥n de objetos con estado")
echo("‚Ä¢ Module Pattern - Encapsulaci√≥n y APIs privadas")
echo("‚Ä¢ Event Emitters - Callbacks que mantienen contexto")
echo("‚Ä¢ Memoization - Cache inteligente de resultados")
echo("‚Ä¢ Currying - Aplicaci√≥n parcial de funciones")
echo("‚Ä¢ State Machines - M√°quinas de estado encapsuladas")
echo("‚Ä¢ Pipelines - Transformaciones de datos componibles")
echo("")

echo("üéâ ¬°Closures completamente implementados en Jabline!")
echo("üíº Listos para usar en aplicaciones de producci√≥n.")
