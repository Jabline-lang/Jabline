// 03_practical_examples.jb - Ejemplos Pr√°cticos de Closures
// =========================================================

echo("üåü CLOSURES EN ESCENARIOS REALES");
echo("================================");
echo("");

// =============================================================================
// 1. SISTEMA DE CONFIGURACI√ìN CON CLOSURES
// =============================================================================

echo("1. SISTEMA DE CONFIGURACI√ìN:");
echo("----------------------------");

fn createConfig(defaults) {
    let config = {};
    let observers = [];

    // Inicializar con valores por defecto
    for (key in defaults) {
        config[key] = defaults[key];
    }

    return {
        "get": fn(key) {
            return config[key];
        },

        "set": fn(key, value) {
            let oldValue = config[key];
            config[key] = value;

            // Notificar a los observers
            for (observer in observers) {
                observer(key, value, oldValue);
            }

            return value;
        },

        "observe": fn(callback) {
            observers[len(observers)] = callback;
        },

        "getAll": fn() {
            let copy = {};
            for (key in config) {
                copy[key] = config[key];
            }
            return copy;
        },

        "reset": fn() {
            for (key in defaults) {
                config[key] = defaults[key];
            }
        }
    };
}

let appConfig = createConfig({
    "theme": "dark",
    "language": "es",
    "debug": false,
    "maxRetries": 3
});

// Observer para cambios de configuraci√≥n
appConfig["observe"](fn(key, newValue, oldValue) {
    echo("  üìù Config changed: " + key + " = " + oldValue + " ‚Üí " + newValue);
});

echo("Tema actual: " + appConfig["get"]("theme"));
appConfig["set"]("theme", "light");
appConfig["set"]("debug", true);
echo("Debug habilitado: " + appConfig["get"]("debug"));
echo("");

// =============================================================================
// 2. CACHE INTELIGENTE CON TTL (Time To Live)
// =============================================================================

echo("2. CACHE CON TTL:");
echo("-----------------");

fn createSmartCache(defaultTTL) {
    let cache = {};
    let accessCount = {};
    let totalHits = 0;
    let totalMisses = 0;

    let getCurrentTime = fn() {
        return 1640995200; // Timestamp simulado
    };

    let isExpired = fn(entry) {
        return getCurrentTime() > entry["expiry"];
    };

    return {
        "set": fn(key, value, ttl) {
            let actualTTL = ttl != null ? ttl : defaultTTL;
            cache[key] = {
                "value": value,
                "expiry": getCurrentTime() + actualTTL,
                "created": getCurrentTime()
            };
            accessCount[key] = 0;
            echo("  üíæ Cached: " + key + " (TTL: " + actualTTL + "s)");
        },

        "get": fn(key) {
            if (cache[key] != null) {
                let entry = cache[key];

                if (isExpired(entry)) {
                    cache[key] = null;
                    accessCount[key] = null;
                    totalMisses = totalMisses + 1;
                    echo("  ‚è∞ Cache EXPIRED for: " + key);
                    return null;
                } else {
                    accessCount[key] = accessCount[key] + 1;
                    totalHits = totalHits + 1;
                    echo("  ‚úÖ Cache HIT for: " + key + " (accessed " + accessCount[key] + " times)");
                    return entry["value"];
                }
            } else {
                totalMisses = totalMisses + 1;
                echo("  ‚ùå Cache MISS for: " + key);
                return null;
            }
        },

        "stats": fn() {
            let activeEntries = 0;
            for (key in cache) {
                if (cache[key] != null && !isExpired(cache[key])) {
                    activeEntries = activeEntries + 1;
                }
            }

            return {
                "hits": totalHits,
                "misses": totalMisses,
                "activeEntries": activeEntries,
                "hitRatio": totalHits / (totalHits + totalMisses)
            };
        },

        "cleanup": fn() {
            let cleaned = 0;
            for (key in cache) {
                if (cache[key] != null && isExpired(cache[key])) {
                    cache[key] = null;
                    accessCount[key] = null;
                    cleaned = cleaned + 1;
                }
            }
            echo("  üßπ Cleaned " + cleaned + " expired entries");
            return cleaned;
        }
    };
}

let smartCache = createSmartCache(30); // 30 segundos por defecto

smartCache["set"]("user:123", "John Doe", 60);
smartCache["set"]("session:abc", "active", 15);

let user = smartCache["get"]("user:123");
echo("Usuario obtenido: " + user);

let session = smartCache["get"]("session:abc");
echo("Sesi√≥n obtenida: " + session);

// Intentar obtener datos inexistentes
let missing = smartCache["get"]("nonexistent");

let stats = smartCache["stats"]();
echo("Cache stats - Hits: " + stats["hits"] + ", Misses: " + stats["misses"]);
echo("");

// =============================================================================
// 3. WORKER QUEUE CON CLOSURES
// =============================================================================

echo("3. WORKER QUEUE:");
echo("----------------");

fn createWorkerQueue(concurrency) {
    let queue = [];
    let running = [];
    let completed = 0;
    let failed = 0;

    let processNext = fn() {
        if (len(queue) > 0 && len(running) < concurrency) {
            let task = queue[0];
            // Remover primer elemento (simulaci√≥n de shift)
            let newQueue = [];
            for (let i = 1; i < len(queue); i++) {
                newQueue[i-1] = queue[i];
            }
            queue = newQueue;

            running[len(running)] = task;
            echo("  üèÉ Ejecutando tarea: " + task["id"]);

            // Simular ejecuci√≥n
            try {
                let result = task["fn"]();

                // Remover de running (simulado)
                let newRunning = [];
                for (runningTask in running) {
                    if (runningTask["id"] != task["id"]) {
                        newRunning[len(newRunning)] = runningTask;
                    }
                }
                running = newRunning;

                completed = completed + 1;
                echo("  ‚úÖ Tarea completada: " + task["id"] + " ‚Üí " + result);

                if (task["onSuccess"] != null) {
                    task["onSuccess"](result);
                }

            } catch {
                failed = failed + 1;
                echo("  ‚ùå Tarea fall√≥: " + task["id"]);

                if (task["onError"] != null) {
                    task["onError"]("Error simulado");
                }
            }

            // Procesar siguiente tarea
            processNext();
        }
    };

    return {
        "add": fn(taskId, taskFn, onSuccess, onError) {
            let task = {
                "id": taskId,
                "fn": taskFn,
                "onSuccess": onSuccess,
                "onError": onError
            };

            queue[len(queue)] = task;
            echo("  üìù Tarea agregada: " + taskId + " (cola: " + len(queue) + ")");

            // Intentar procesar inmediatamente
            processNext();
        },

        "getStatus": fn() {
            return {
                "queued": len(queue),
                "running": len(running),
                "completed": completed,
                "failed": failed
            };
        },

        "clear": fn() {
            queue = [];
            let wasRunning = len(running);
            running = [];
            echo("  üßπ Queue cleared. Interrumpidas " + wasRunning + " tareas");
        }
    };
}

let workerQueue = createWorkerQueue(2); // m√°ximo 2 tareas concurrentes

// Agregar tareas
workerQueue["add"]("task-1", fn() { return "Resultado 1"; },
    fn(result) { echo("    üìà Success callback: " + result); },
    fn(error) { echo("    üìâ Error callback: " + error); }
);

workerQueue["add"]("task-2", fn() { return "Resultado 2"; }, null, null);
workerQueue["add"]("task-3", fn() { return "Resultado 3"; }, null, null);

let status = workerQueue["getStatus"]();
echo("Estado: " + status["completed"] + " completadas, " + status["queued"] + " en cola");
echo("");

// =============================================================================
// 4. SISTEMA DE VALIDACI√ìN COMPLEJO
// =============================================================================

echo("4. SISTEMA DE VALIDACI√ìN:");
echo("-------------------------");

fn createValidator() {
    let rules = {};

    let validateValue = fn(value, ruleSet) {
        let errors = [];

        for (rule in ruleSet) {
            if (!rule["fn"](value)) {
                errors[len(errors)] = rule["message"];
            }
        }

        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "value": value
        };
    };

    return {
        "addRule": fn(field, ruleFn, message) {
            if (rules[field] == null) {
                rules[field] = [];
            }

            rules[field][len(rules[field])] = {
                "fn": ruleFn,
                "message": message
            };
        },

        "validate": fn(data) {
            let result = {
                "valid": true,
                "errors": {},
                "fieldResults": {}
            };

            for (field in rules) {
                let fieldValue = data[field];
                let fieldResult = validateValue(fieldValue, rules[field]);

                result["fieldResults"][field] = fieldResult;

                if (!fieldResult["valid"]) {
                    result["valid"] = false;
                    result["errors"][field] = fieldResult["errors"];
                }
            }

            return result;
        },

        "validateField": fn(field, value) {
            if (rules[field] != null) {
                return validateValue(value, rules[field]);
            }
            return {"valid": true, "errors": [], "value": value};
        }
    };
}

let userValidator = createValidator();

// Agregar reglas de validaci√≥n
userValidator["addRule"]("name", fn(value) { return value != null && value != ""; }, "Nombre es requerido");
userValidator["addRule"]("name", fn(value) { return len(value) >= 2; }, "Nombre debe tener al menos 2 caracteres");

userValidator["addRule"]("email", fn(value) { return value != null && value != ""; }, "Email es requerido");
userValidator["addRule"]("email", fn(value) { return indexOf(value, "@") > 0; }, "Email debe contener @");

userValidator["addRule"]("age", fn(value) { return value != null && value >= 18; }, "Debe ser mayor de edad");

// Validar datos
let userData1 = {
    "name": "Juan",
    "email": "juan@example.com",
    "age": 25
};

let validation1 = userValidator["validate"](userData1);
echo("Validaci√≥n 1 - V√°lido: " + validation1["valid"]);

let userData2 = {
    "name": "A",
    "email": "invalid-email",
    "age": 16
};

let validation2 = userValidator["validate"](userData2);
echo("Validaci√≥n 2 - V√°lido: " + validation2["valid"]);

if (!validation2["valid"]) {
    for (field in validation2["errors"]) {
        let fieldErrors = validation2["errors"][field];
        echo("  ‚ùå " + field + ": " + fieldErrors[0]);
    }
}
echo("");

// =============================================================================
// 5. SISTEMA DE MIDDLEWARE/INTERCEPTORES
// =============================================================================

echo("5. SISTEMA DE MIDDLEWARE:");
echo("-------------------------");

fn createMiddlewareSystem() {
    let beforeMiddlewares = [];
    let afterMiddlewares = [];
    let errorMiddlewares = [];

    return {
        "before": fn(middleware) {
            beforeMiddlewares[len(beforeMiddlewares)] = middleware;
        },

        "after": fn(middleware) {
            afterMiddlewares[len(afterMiddlewares)] = middleware;
        },

        "error": fn(middleware) {
            errorMiddlewares[len(errorMiddlewares)] = middleware;
        },

        "execute": fn(mainFunction, context) {
            let result = null;
            let error = null;

            try {
                // Ejecutar middlewares "before"
                for (middleware in beforeMiddlewares) {
                    echo("  ‚èØÔ∏è  Before middleware ejecutado");
                    context = middleware(context);
                }

                // Ejecutar funci√≥n principal
                echo("  üéØ Ejecutando funci√≥n principal");
                result = mainFunction(context);

                // Ejecutar middlewares "after"
                for (middleware in afterMiddlewares) {
                    echo("  ‚è≠Ô∏è  After middleware ejecutado");
                    result = middleware(result, context);
                }

            } catch (e) {
                error = e;
                echo("  ‚ùå Error capturado: " + error);

                // Ejecutar middlewares de error
                for (middleware in errorMiddlewares) {
                    echo("  üö® Error middleware ejecutado");
                    error = middleware(error, context);
                }
            }

            if (error != null) {
                return {"success": false, "error": error};
            } else {
                return {"success": true, "result": result};
            }
        }
    };
}

let middlewareSystem = createMiddlewareSystem();

// Configurar middlewares
middlewareSystem["before"](fn(context) {
    echo("    üîê Autenticaci√≥n verificada para: " + context["user"]);
    return context;
});

middlewareSystem["before"](fn(context) {
    echo("    üìä Logging request para: " + context["action"]);
    return context;
});

middlewareSystem["after"](fn(result, context) {
    echo("    ‚úÖ Respuesta preparada: " + result);
    return result;
});

middlewareSystem["error"](fn(error, context) {
    echo("    üìù Error logged para usuario: " + context["user"]);
    return "Error procesado: " + error;
});

// Funci√≥n principal de negocio
let businessLogic = fn(context) {
    return "Operaci√≥n completada para " + context["user"];
};

// Ejecutar con middleware
let executionResult = middlewareSystem["execute"](businessLogic, {
    "user": "juan123",
    "action": "getData"
});

echo("Resultado final: " + executionResult["result"]);
echo("");

// =============================================================================
// CONCLUSIONES Y MEJORES PR√ÅCTICAS
// =============================================================================

echo("üìö MEJORES PR√ÅCTICAS CON CLOSURES:");
echo("==================================");
echo("‚Ä¢ ‚úÖ Usar closures para encapsular estado privado");
echo("‚Ä¢ ‚úÖ Crear APIs fluidas y expresivas");
echo("‚Ä¢ ‚úÖ Implementar patrones observer y middleware");
echo("‚Ä¢ ‚úÖ Cachear resultados costosos con memoizaci√≥n");
echo("‚Ä¢ ‚úÖ Gestionar recursos con contadores y l√≠mites");
echo("‚Ä¢ ‚úÖ Validar datos con reglas componibles");
echo("‚Ä¢ ‚úÖ Procesar tareas as√≠ncronas con colas");
echo("‚Ä¢ ‚úÖ Configurar aplicaciones con observers");
echo("");

echo("‚ö†Ô∏è  CONSIDERACIONES IMPORTANTES:");
echo("================================");
echo("‚Ä¢ Cuidado con el consumo de memoria (variables capturadas)");
echo("‚Ä¢ Los closures mantienen referencias a su scope externo");
echo("‚Ä¢ √ötiles para crear APIs privadas y p√∫blicas");
echo("‚Ä¢ Perfectos para patrones factory y module");
echo("‚Ä¢ Ideales para programaci√≥n funcional avanzada");
echo("");

echo("üéâ ¬°Closures pr√°cticos funcionando en Jabline!");
echo("üíº Listos para usar en aplicaciones reales.");
